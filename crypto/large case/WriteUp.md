# 题目解析(wp)
观察题目，可以发现首先需要恢复e，由于e的因子分别是p-1,q-1,r-1的因子，分别分解p-1,q-1,r-1并进行判断可以恢复e。由于e和phi非互质，我们有`pow(t,p-1,p)==pow(t,ep*(p-1)//ep,p)==pow(pow(t,ep,p),(p-1)//ep,p)==1`，即`GF(p)`的一个生成元经过加密后会变成其一$\frac{p-1}{e_p}$阶子群的生成元，可以利用这一性质恢复e。
此外，由于`pow(x,phi//e,n)==1`是一个$\frac{\varphi}{e}$阶子群，本题中$e$没有重指数，`gcd(e,phi//e)=1`，因此可以在子群上对于$c$解RSA得到`pow(m,e,n)==c`的一个根，无需使用AMM算法而且代码简单。
若想找到`pow(m,e,n)==c`的全部$e$个根，可以通过这一个根和`pow(x,e,n)==1`的$e$个根组合得到。而`pow(x,e,n)==1`的$e$个根可以由子群中一个随机生成元`g=pow(t,phi//e,n)`通过指数生成。
综上，我们得到了一种更为简单的非互质RSA解密方法，详细解释可以翻阅论文和代码。如果直接对$n$上考虑生成元，也无需进行CRT过程，由于每步循环只需进行一次乘法和一次模运算，效率提高60%以上。
本题中在`Zmod(n)`上`e=757*66553*5156273`，还是有些过大，考虑将其降到`Zmod(p*q)`上。由于题目的padding方式是末尾补零，相当于简单的移位，利用RSA的同态性可以除去`pow(256**L,e,n)`消去padding，使明文在`Zmod(p*q)`范围类。再运用前述算法不加其它优化约一小时左右能出结果。
当然，由于算法的简单性，我们可以很容易对其进行并行化改造。只需简单开个八核并行，就能在十分钟之内得到结果，即使在个人能力赛中也很容易实现。（虽然很可惜并没有人做出来）
For foreign players, you can read the paper's explanation and exp directly.

# 解题脚本(exp)
solution.py

# 花絮
出题人做starCTF2021的little case时，翻了半天论文才解出来，但看官方wp并没有很好的解释，所以魔改了一下出了这道题。为了突出算法的高效性，本题调整了参数，希望能让大家不用AMM+CRT的解法，但效果并不理想。（经测试，普通的AMM+CRT运行一次就需要浪费两三个小时，没想到大家都很有耐心。。。）由于疫情等等原因，比赛拖了有将近一年的时间，SUSCTF2021也变成SUSCTF2022了，这题才和大家见面。长时间以来，这个考点也不算新奇了（比如月初DiceCTF2022的baby-rsa也是这个考点），不过本题参考的论文，不同于之前同类题目参考的零散知识点，我觉得是对非互质RSA解密的一个较好总结了。